package lexsyn;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;

action code {:
	class TableS {
		static final int size = 100;
		String name[] = new String[size];
		String atribute[] = new String[size];
		int level[] = new int[size];
		int col[] = new int[size];
	}

	class Hash extends Thread {
		final static int maxLevel = 1000;
		int scope[] = new int[10];
		int hashTable[] = new int[509];
		int curLevel;
		int last; // index of last element on the table
		int root; // index of first element on the table
		TableS tb = new TableS();

		public Hash() {
			last = 1;
			root = 0;
			curLevel = 1;
			scope[curLevel] = 1;
		}

		/* Methods */
		void error(int errorNumber) {
			switch(errorNumber) {
				case 1:
					System.out.println("Symbol table is full.");
					break;
				case 2:
					System.out.println("Item was not found.");
					break;
				case 3:
					System.out.println("Item already on the table.");
					break;
				default:
			}
		}

		void enterBlock() {
			curLevel++;

			if (curLevel > maxLevel)
				error(1);
			else
				scope[curLevel] = last;
		}

		void exitBlock() {
			int S, B, k;
			String ident;

			S = last;
			B = scope[curLevel];
			while (S > B) {
				S--;
				k = (int)tb.name[S].charAt(0);
				hashTable[k] = tb.col[S];
			}

			last = scope[curLevel];
			curLevel--;
		}

		int getEntry(String x) {
			int n, aux, k;
			boolean found;

			found = false;
			n = (int)x.charAt(0);
			k = hashTable[n];

			while ((k != 0) && (!found)) {
				if (x.equals(tb.name[k]))
					found = true;
				else
					k = tb.col[k];
			}

			if (found)
				return k;
			else
				error(2);

			return -1;
		}

		void install(String x, String atribute) {
			int n, k, aux;
			boolean equals = false;

			n = (int)x.charAt(0);
			k = hashTable[n];

			while (k >= scope[curLevel]) {
				if (x.equals(tb.name[k]))
					equals = true;

				k = tb.col[k];
			}

			if (last == (maxLevel + 1))
				error(1);
			else if (!equals) {
				tb.level[last] = curLevel;
				tb.atribute[last] = atribute;
				tb.name[last] = x;
				tb.col[last] = hashTable[n];
				hashTable[n] = last;
				last++;
			}
		}
	}

	Hash h = new Hash();
:}

parser code {:
	public static void main(String args[]) throws Exception {
		System.out.println("----------------------");
		parser myParser = new parser(new Yylex(System.in));
		myParser.parse();
		System.out.println("Done.");
	}
:}

terminal LCBRACK, RCBRACK, SEMI, LPAREN, RPAREN;
terminal INTT, CHART, BOOLT, FLOATT;
terminal ASSIGN;
terminal WHILE, IF, ELSE;

terminal INTN;
terminal REALN;

terminal ID;

terminal LT, LE, GT, GE;
terminal PLUS, MINUS, MUL, DIV;

non terminal program, block, decls, decl, type, stmts, stmt, rel, expr, term;
non terminal unary, factor;

precedence left PLUS, MINUS, MUL, DIV, ELSE;

program	::= block:b {:
				System.out.println("\n----------------------");
				String rules = new String("program -> block\n" + b);
				System.out.print(rules);
			:}
	;
block	::= LCBRACK decls:ds stmts:ss RCBRACK {:
				RESULT = new String("block -> { decls stmts }\n" + ds + ss);
			:}
	;
decls	::= decls:ds decl:d {:
				RESULT = new String("decls -> decls decl\n" + ds + d);
			:}
	|		/* empty */ {:
				RESULT = new String("decls -> \n\n");
			:}
	;
decl 	::= type:t ID SEMI {:
				RESULT = new String("decl -> type id;\n" + t);
			:}
	;
type	::= INTT {:
				RESULT = new String("type -> int\n\n");
			:} 
	|		CHART {:
				RESULT = new String("type -> char\n\n");
			:}
	|		BOOLT {:
				RESULT = new String("type -> bool\n\n");
			:}
	|		FLOATT {:
				RESULT = new String("type -> float\n\n");
			:}
	;
stmts	::= stmts:ss stmt:s {:
				RESULT = new String("stmts -> stmts stmt\n" + ss + s);
			:}
	| 		/* empty */ {:
				RESULT = new String("stmts -> \n\n");
			:}
	;
stmt 	::= ID ASSIGN expr:e SEMI {:
				RESULT = new String("stmt -> id = expr;\n" + e);
			:}
	| 		IF LPAREN rel:r RPAREN stmt:s {:
				RESULT = new String("stmt -> if ( rel ) stmt\n" + r + s);
			:}
	| 		IF LPAREN rel:r RPAREN stmt:s1 ELSE stmt:s2 {:
				RESULT = new String("stmt -> if ( rel ) stmt else stmt\n" + r + s1 + s2);
			:}
	|		WHILE LPAREN rel:r RPAREN stmt:s {:
				RESULT = new String("stmt -> while ( rel ) stmt\n" + r + s);
			:}
	|		block:b {:
				RESULT = new String("stmt -> block\n" + b);
			:}
	;
rel 	::= expr:e1 LT expr:e2 {:
				RESULT = new String("rel -> expr < expr\n" + e1 + e2);
			:}
	| 		expr:e1 LE expr:e2 {:
				RESULT = new String("rel -> expr <= expr\n" + e1 + e2);
			:}
	| 		expr:e1 GT expr:e2 {:
				RESULT = new String("rel -> expr > expr\n" + e1 + e2);
			:}
	| 		expr:e1 GE expr:e2 {:
				RESULT = new String("rel -> expr >= expr\n" + e1 + e2);
			:}
	|		expr:e {:
				RESULT = new String("rel -> expr\n" + e);
			:}
	;
expr 	::= expr:e PLUS term:t {:
				RESULT = new String("expr -> expr + term\n" + e + t);
			:}
	| 		expr:e MINUS term:t {:
				RESULT = new String("expr -> expr - term\n" + e + t);
			:}
	| 		term:t {:
				RESULT = new String("expr -> term\n" + t);
			:}
	;
term 	::= term:t MUL unary:u {:
				RESULT = new String("term -> term * unary\n" + t + u);
			:}
 	| 		term:t DIV unary:u {:
				RESULT = new String("term -> term / unary\n" + t + u);
			:}
 	| 		unary:u {:
				RESULT = new String("term -> unary\n" + u);
			:}
 	;
unary 	::= MINUS unary:u {:
				RESULT = new String("unary -> - unary\n" + u);
			:}
	| 		factor:f {:
				RESULT = new String("unary -> factor\n" + f);
			:} 
	;
factor 	::= INTN:n {:
				RESULT = new String("factor -> num\n\n");
			:}
	| 		REALN:n {:
				RESULT = new String("factor -> real\n\n");
			:}
	;